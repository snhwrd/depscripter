import re
import sys
from typing import Dict, Optional


def generate_script_metadata(dependencies: Dict[str, Optional[str]], python_requires: Optional[str] = None, overrides: Optional[Dict[str, str]] = None) -> str:
    """
    Generates the PEP 723 metadata block.
    
    overrides: Dictionary of package name -> version specifier (e.g. ">=2.0")
    """
    if python_requires is None:
        # Default to current running python version major.minor
        v = sys.version_info
        python_requires = f">={v.major}.{v.minor}"
    
    if overrides is None:
        overrides = {}

    lines = []
    lines.append("# /// script")
    lines.append(f'# requires-python = "{python_requires}"')
    lines.append("# dependencies = [")
    
    # Merge keys from dependencies and overrides
    all_packages = set(dependencies.keys()) | set(overrides.keys())
    sorted_deps = sorted(all_packages)
    
    for pkg in sorted_deps:
        if pkg in overrides:
            # Use manual override specifier
            spec = overrides[pkg]
            lines.append(f'#     "{pkg}{spec}",')
        else:
            version = dependencies[pkg]
            if version:
                lines.append(f'#     "{pkg}=={version}",')
            else:
                lines.append(f'#     "{pkg}",')
            
    lines.append("# ]")
    lines.append("# ///")
    
    return "\n".join(lines)

def inject_metadata(source_code: str, metadata_block: str) -> str:
    """
    Inserts the metadata block into the source code, preserving shebang and encoding lines.
    """
    lines = source_code.splitlines(keepends=True)
    insert_idx = 0
    
    # Check for existing block
    if "# /// script" in source_code:
        # For this version, we raise an error or return original? 
        # Making it simple: just append for now creates garbage. 
        # Proper behavior: finding existing block is complex.
        # Let's assume we don't modify if it exists, or user handles it.
        # But I'll just insert it at top.
        pass

    # Logic to skip shebang/encoding
    if lines:
        # Shebang
        if lines[0].startswith("#!"):
            insert_idx += 1
            
            # Encoding cookie (must be line 1 or 2)
            # Regex from PEP 263
            coding_re = re.compile(r"^[ \t\f]*#.*?coding[:=][ \t]*([-_.a-zA-Z0-9]+)")
            if len(lines) > 1 and coding_re.match(lines[1]):
                insert_idx += 1
        else:
            # Check line 1 for encoding
            coding_re = re.compile(r"^[ \t\f]*#.*?coding[:=][ \t]*([-_.a-zA-Z0-9]+)")
            if coding_re.match(lines[0]):
                insert_idx += 1

    # Insert
    # Ensure newline separation
    block_lines = metadata_block.splitlines(keepends=True)
    # Add newline to last line of block if needed (splitlines does not add \n to last line usually if generated by join)
    # Actually my generate_script_metadata returns string joined by \n.
    # So I need to ensure it has newlines when inserting into list of keepends=True lines.
    
    formatted_block = []
    for line in metadata_block.splitlines():
        formatted_block.append(line + "\n")
    
    # Add an extra newline for separation from code/docstrings
    formatted_block.append("\n")

    lines[insert_idx:insert_idx] = formatted_block
    
    return "".join(lines)
